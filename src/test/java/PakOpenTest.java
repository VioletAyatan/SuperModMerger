import ankol.mod.merger.antlr.json.JSONLexer;
import ankol.mod.merger.antlr.json.JSONParser;
import ankol.mod.merger.antlr.scr.TechlandScriptLexer;
import ankol.mod.merger.antlr.scr.TechlandScriptParser;
import ankol.mod.merger.core.BaseTreeNode;
import ankol.mod.merger.merger.json.TechlandJsonFileVisitor;
import ankol.mod.merger.tools.Tools;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.atn.ATNConfigSet;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.misc.Interval;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.apache.commons.lang3.Strings;
import org.junit.Test;
import tool.TestTool;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.BitSet;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.stream.Stream;

public class PakOpenTest {
    private final String[] scrFileSuffix = new String[]{".scr", ".def", ".loot", ".phx", ".ppfx", ".ares", ".mpcloth"};
    private final String[] jsonFileSuffix = new String[]{".model", ".gui"};

    /**
     * 遍历Techlandpak包测试
     */
    @Test
    public void test() {
        StringBuilder dltbPath = TestTool.getDltbPath();
        if (dltbPath == null) return;
        String pakFilePath = dltbPath.append(String.join(File.separator, "", "ph_ft", "source", "data0.pak")).toString();
        System.out.println("pakFilePath = " + pakFilePath);
        long count = 0;
        try (ZipFile zipFile = ZipFile.builder().setFile(pakFilePath).get()) {
            Enumeration<ZipArchiveEntry> entries = zipFile.getEntries();
            while (entries.hasMoreElements()) {
                count++;
                ZipArchiveEntry zipEntry = entries.nextElement();
                String entryName = zipEntry.getName();
                try {
                    if (zipEntry.getSize() == 0) {
                        System.err.println("文件为空，跳过处理：" + entryName);
                    } else {
                        if (Strings.CI.endsWithAny(entryName, scrFileSuffix)) {
                            System.out.println("zipEntry = " + entryName);
                            TechlandScriptParser parser = getScrParser(zipFile.getInputStream(zipEntry), entryName).parser();
                            parser.file();
                        } else if (Strings.CI.endsWithAny(entryName, jsonFileSuffix)) {
                            System.out.println("zipEntry = " + entryName);
                            JSONParser parser = getJsonParser(zipFile.getInputStream(zipEntry), entryName);
                            parser.json();
                        } else {
//                            System.err.println("不支持的类型，跳过处理：" + entryName);
                        }
                    }
                } catch (IOException e) {
                    System.err.println("文件：" + entryName + "处理失败，跳过！" + e.getMessage());
                }
            }
            System.out.println("遍历完成，总文件数：" + count + "个");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testDL2() {
        HashSet<String> files = new HashSet<>();
        var path = "D:\\SteamLibrary\\steamapps\\common\\Dying Light 2\\ph\\source\\data0.pak";
        try (ZipFile zipFile = ZipFile.builder().setFile(path).get()) {
            Enumeration<ZipArchiveEntry> entries = zipFile.getEntries();
            while (entries.hasMoreElements()) {
                ZipArchiveEntry zipEntry = entries.nextElement();
                String entryName = zipEntry.getName();
                String fileName = Tools.getEntryFileName(entryName);
                if (files.contains(fileName)) {
                    System.err.println("发现重复的文件：" + fileName + " -> " + entryName);
                } else {
                    files.add(fileName);
//                    System.out.println("entryName = " + entryName);
                }
            }
            System.out.println("完成，总处理文件数：" + files.size() + "个");
        } catch (RuntimeException | IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void fileParseTest() {
        try {
            Path filePath = Path.of("C:\\Users\\Administrator\\Desktop\\困兽mod开发\\data0\\gui\\common_pc\\dark_edges_pc.gui");
            String fileName = filePath.getFileName().toString();
            if (Strings.CI.endsWithAny(fileName, scrFileSuffix)) {
                TechlandScriptParser parser = getScrParser(filePath, fileName).parser();
                parser.file();
            } else if (Strings.CI.endsWithAny(fileName, jsonFileSuffix)) {
                JSONParser parser = getJsonParser(filePath, fileName);
                BaseTreeNode treeNode = new TechlandJsonFileVisitor(parser.getTokenStream()).visit(parser.json());
                System.out.println("treeNode = " + treeNode);
            } else {
                System.err.println("不支持的类型，跳过处理：" + fileName);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void walkDirTest() throws IOException {
        Path path = Path.of("C:\\Users\\Administrator\\Desktop\\data7");
        try (Stream<Path> pathStream = Files.walk(path)) {
            pathStream.filter(Files::isRegularFile)
                    .forEach(file -> {
                        try {
                            String fileName = file.getFileName().toString();
                            if (Strings.CI.endsWithAny(fileName, scrFileSuffix)) {
                                System.out.println("fileName = " + fileName);
                                TechlandScriptParser parser = getScrParser(file, fileName).parser();
                                parser.file();
                            } else if (Strings.CI.endsWithAny(fileName, jsonFileSuffix)) {
                                System.out.println("fileName = " + fileName);
                                JSONParser parser = getJsonParser(file, fileName);
                                parser.json();
                            } else {
                                System.err.println("不支持的类型，跳过处理：" + fileName);
                            }
                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }
                    });
        }
    }

    private ParseContext<TechlandScriptLexer, TechlandScriptParser> getScrParser(InputStream inputStream, String entryName) throws IOException {
        CharStream input = CharStreams.fromStream(inputStream);
        var lexer = new TechlandScriptLexer(input);
        var tokens = new CommonTokenStream(lexer);
        TechlandScriptParser parser = new TechlandScriptParser(tokens);
        /*parser.addErrorListener(new ANTLRErrorListener() {
            @Override
            public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
                String errorToken = offendingSymbol != null ? offendingSymbol.toString() : "未知";
                System.err.println("【语法错误】文件: " + entryName);
                System.err.println("  位置: 第 " + line + " 行，第 " + charPositionInLine + " 列");
                System.err.println("  错误符号: " + errorToken);
                System.err.println("  错误信息: " + msg);
                if (e != null) {
                    System.err.println("  异常类型: " + e.getClass().getSimpleName());
                }
                System.err.println();
            }

            @Override
            public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs) {
                TokenStream tokens = recognizer.getTokenStream();
                String ambiguousText = tokens.getText(new Interval(startIndex, stopIndex));
                Token startToken = tokens.get(startIndex);
                System.err.println("【语法二义性警告】文件: " + entryName);
                System.err.println("  位置: 第 " + startToken.getLine() + " 行");
                System.err.println("  二义性文本: " + ambiguousText);
                System.err.println("  Token范围: [" + startIndex + ", " + stopIndex + "]");
                System.err.println("  是否精确匹配: " + exact);

                // 显示具体的二义性匹配路径
                if (ambigAlts != null) {
                    System.err.println("  可能的解析路径数: " + ambigAlts.cardinality());
                    System.err.println("  具体的二义性路径:");
                    for (int i = ambigAlts.nextSetBit(0); i >= 0; i = ambigAlts.nextSetBit(i + 1)) {
                        System.err.println("    - 路径 " + i + ": " + recognizer.getRuleNames()[dfa.atnStartState.ruleIndex] + " (alt " + i + ")");
                    }
                } else {
                    System.err.println("  可能的解析路径数: 未知");
                }

                // 显示配置集信息
                if (configs != null && configs.size() > 0) {
                    System.err.println("  配置集详情 (前5个):");
                    int count = 0;
                    for (var config : configs) {
                        if (count >= 5) break;
                        System.err.println("    - 状态: " + config.state + ", Alt: " + config.alt + ", Context: " + config.context);
                        count++;
                    }
                    if (configs.size() > 5) {
                        System.err.println("    ... 还有 " + (configs.size() - 5) + " 个配置");
                    }
                }
                System.err.println();
            }

            @Override
            public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) {
                TokenStream tokens = recognizer.getTokenStream();
                String contextText = tokens.getText(new Interval(startIndex, stopIndex));
                Token startToken = tokens.get(startIndex);
                System.out.println("【性能提示】文件: " + entryName);
                System.out.println("  位置: 第 " + startToken.getLine() + " 行");
                System.out.println("  解析器尝试使用完整上下文进行匹配");
                System.out.println("  上下文文本: " + contextText);
                System.out.println("  Token范围: [" + startIndex + ", " + stopIndex + "]");
                System.out.println();
            }

            @Override
            public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs) {
                TokenStream tokens = recognizer.getTokenStream();
                String contextText = tokens.getText(new Interval(startIndex, stopIndex));
                Token startToken = tokens.get(startIndex);
                System.err.println("【上下文敏感警告】文件: " + entryName);
                System.err.println("  位置: 第 " + startToken.getLine() + " 行");
                System.err.println("  上下文敏感文本: " + contextText);
                System.err.println("  Token范围: [" + startIndex + ", " + stopIndex + "]");
                System.err.println("  预测结果: " + prediction);
                System.err.println("  说明: 解析器需要上下文信息才能做出决策");
                System.err.println();
            }

        });*/
        return new ParseContext<>(input, tokens, lexer, parser);
    }

    private ParseContext<TechlandScriptLexer, TechlandScriptParser> getScrParser(Path path, String entryName) throws IOException {
        var input = CharStreams.fromPath(path);
        var lexer = new TechlandScriptLexer(input);
        var tokens = new CommonTokenStream(lexer);
        TechlandScriptParser parser = new TechlandScriptParser(tokens);
        parser.addErrorListener(new ANTLRErrorListener() {
            @Override
            public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
                String errorToken = offendingSymbol != null ? offendingSymbol.toString() : "未知";
                System.err.println("【语法错误】文件: " + entryName);
                System.err.println("  位置: 第 " + line + " 行，第 " + charPositionInLine + " 列");
                System.err.println("  错误符号: " + errorToken);
                System.err.println("  错误信息: " + msg);
                if (e != null) {
                    System.err.println("  异常类型: " + e.getClass().getSimpleName());
                }
                System.err.println();
            }

            @Override
            public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs) {
                TokenStream tokens = recognizer.getTokenStream();
                String ambiguousText = tokens.getText(new Interval(startIndex, stopIndex));
                Token startToken = tokens.get(startIndex);
                System.err.println("【语法二义性警告】文件: " + entryName);
                System.err.println("  位置: 第 " + startToken.getLine() + " 行");
                System.err.println("  二义性文本: " + ambiguousText);
                System.err.println("  Token范围: [" + startIndex + ", " + stopIndex + "]");
                System.err.println("  是否精确匹配: " + exact);

                // 显示具体的二义性匹配路径
                if (ambigAlts != null) {
                    System.err.println("  可能的解析路径数: " + ambigAlts.cardinality());
                    System.err.println("  具体的二义性路径:");
                    for (int i = ambigAlts.nextSetBit(0); i >= 0; i = ambigAlts.nextSetBit(i + 1)) {
                        System.err.println("    - 路径 " + i + ": " + recognizer.getRuleNames()[dfa.atnStartState.ruleIndex] + " (alt " + i + ")");
                    }
                } else {
                    System.err.println("  可能的解析路径数: 未知");
                }

                // 显示配置集信息
                if (configs != null && !configs.isEmpty()) {
                    System.err.println("  配置集详情 (前5个):");
                    int count = 0;
                    for (var config : configs) {
                        if (count >= 5) break;
                        System.err.println("    - 状态: " + config.state + ", Alt: " + config.alt + ", Context: " + config.context);
                        count++;
                    }
                    if (configs.size() > 5) {
                        System.err.println("    ... 还有 " + (configs.size() - 5) + " 个配置");
                    }
                }
                System.err.println();
            }

            @Override
            public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) {
                TokenStream tokens = recognizer.getTokenStream();
                String contextText = tokens.getText(new Interval(startIndex, stopIndex));
                Token startToken = tokens.get(startIndex);
                System.out.println("【性能提示】文件: " + entryName);
                System.out.println("  位置: 第 " + startToken.getLine() + " 行");
                System.out.println("  解析器尝试使用完整上下文进行匹配");
                System.out.println("  上下文文本: " + contextText);
                System.out.println("  Token范围: [" + startIndex + ", " + stopIndex + "]");
                System.out.println();
            }

            @Override
            public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs) {
                TokenStream tokens = recognizer.getTokenStream();
                String contextText = tokens.getText(new Interval(startIndex, stopIndex));
                Token startToken = tokens.get(startIndex);
                System.err.println("【上下文敏感警告】文件: " + entryName);
                System.err.println("  位置: 第 " + startToken.getLine() + " 行");
                System.err.println("  上下文敏感文本: " + contextText);
                System.err.println("  Token范围: [" + startIndex + ", " + stopIndex + "]");
                System.err.println("  预测结果: " + prediction);
                System.err.println("  说明: 解析器需要上下文信息才能做出决策");
                System.err.println();
            }
        });
        return new ParseContext<>(input, tokens, lexer, parser);
    }

    private JSONParser getJsonParser(InputStream inputStream, String entryName) throws IOException {
        var input = CharStreams.fromStream(inputStream);
        var lexer = new JSONLexer(input);
        var tokens = new CommonTokenStream(lexer);
        JSONParser parser = new JSONParser(tokens);
        parser.addErrorListener(new ANTLRErrorListener() {
            @Override
            public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
                String errorToken = offendingSymbol != null ? offendingSymbol.toString() : "未知";
                System.err.println("【JSON语法错误】文件: " + entryName);
                System.err.println("  位置: 第 " + line + " 行，第 " + charPositionInLine + " 列");
                System.err.println("  ���误符号: " + errorToken);
                System.err.println("  错误信息: " + msg);
                if (e != null) {
                    System.err.println("  异常类型: " + e.getClass().getSimpleName());
                }
                System.err.println();
            }

            @Override
            public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs) {
                TokenStream tokens = recognizer.getTokenStream();
                String ambiguousText = tokens.getText(new Interval(startIndex, stopIndex));
                Token startToken = tokens.get(startIndex);
                System.err.println("【JSON语法二义性警告】文件: " + entryName);
                System.err.println("  位置: 第 " + startToken.getLine() + " 行");
                System.err.println("  二义性文本: " + ambiguousText);
                System.err.println("  Token范围: [" + startIndex + ", " + stopIndex + "]");
                System.err.println("  是否精确匹配: " + exact);

                // 显示具体的二义性匹配路径
                if (ambigAlts != null) {
                    System.err.println("  可能的解析路径数: " + ambigAlts.cardinality());
                    System.err.println("  具体的二义性路径:");
                    for (int i = ambigAlts.nextSetBit(0); i >= 0; i = ambigAlts.nextSetBit(i + 1)) {
                        System.err.println("    - 路径 " + i + ": " + recognizer.getRuleNames()[dfa.atnStartState.ruleIndex] + " (alt " + i + ")");
                    }
                } else {
                    System.err.println("  可能的解析路径数: 未知");
                }

                // 显示配置集信息
                if (configs != null && configs.size() > 0) {
                    System.err.println("  配置集详情 (前5个):");
                    int count = 0;
                    for (var config : configs) {
                        if (count >= 5) break;
                        System.err.println("    - 状态: " + config.state + ", Alt: " + config.alt + ", Context: " + config.context);
                        count++;
                    }
                    if (configs.size() > 5) {
                        System.err.println("    ... 还有 " + (configs.size() - 5) + " 个配置");
                    }
                }
                System.err.println();
            }

            @Override
            public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) {
                TokenStream tokens = recognizer.getTokenStream();
                String contextText = tokens.getText(new Interval(startIndex, stopIndex));
                Token startToken = tokens.get(startIndex);
                System.out.println("【JSON性能提示】文件: " + entryName);
                System.out.println("  位置: 第 " + startToken.getLine() + " 行");
                System.out.println("  解析器尝试使用完整上下文进行匹配");
                System.out.println("  上下文文本: " + contextText);
                System.out.println("  Token范围: [" + startIndex + ", " + stopIndex + "]");
                System.out.println();
            }

            @Override
            public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs) {
                TokenStream tokens = recognizer.getTokenStream();
                String contextText = tokens.getText(new Interval(startIndex, stopIndex));
                Token startToken = tokens.get(startIndex);
                System.err.println("【JSON上下文敏感警告】文件: " + entryName);
                System.err.println("  位置: 第 " + startToken.getLine() + " 行");
                System.err.println("  上下文敏感文本: " + contextText);
                System.err.println("  Token范围: [" + startIndex + ", " + stopIndex + "]");
                System.err.println("  预测结果: " + prediction);
                System.err.println("  说明: JSON解析器需要上下文信息才能做出决策");
                System.err.println();
            }
        });
        return parser;
    }

    private JSONParser getJsonParser(Path path, String entryName) throws IOException {
        var input = CharStreams.fromPath(path);
        var lexer = new JSONLexer(input);
        var tokens = new CommonTokenStream(lexer);
        JSONParser parser = new JSONParser(tokens);
        parser.addErrorListener(new ANTLRErrorListener() {
            @Override
            public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
                String errorToken = offendingSymbol != null ? offendingSymbol.toString() : "未知";
                System.err.println("【JSON语法错误】文件: " + entryName);
                System.err.println("  位置: 第 " + line + " 行，第 " + charPositionInLine + " 列");
                System.err.println("  ���误符号: " + errorToken);
                System.err.println("  错误信息: " + msg);
                if (e != null) {
                    System.err.println("  异常类型: " + e.getClass().getSimpleName());
                }
                System.err.println();
            }

            @Override
            public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs) {
                TokenStream tokens = recognizer.getTokenStream();
                String ambiguousText = tokens.getText(new Interval(startIndex, stopIndex));
                Token startToken = tokens.get(startIndex);
                System.err.println("【JSON语法二义性警告】文件: " + entryName);
                System.err.println("  位置: 第 " + startToken.getLine() + " 行");
                System.err.println("  二义性文本: " + ambiguousText);
                System.err.println("  Token范围: [" + startIndex + ", " + stopIndex + "]");
                System.err.println("  是否精确匹配: " + exact);

                // 显示具体的二义性匹配路径
                if (ambigAlts != null) {
                    System.err.println("  可能的解析路径数: " + ambigAlts.cardinality());
                    System.err.println("  具体的二义性路径:");
                    for (int i = ambigAlts.nextSetBit(0); i >= 0; i = ambigAlts.nextSetBit(i + 1)) {
                        System.err.println("    - 路径 " + i + ": " + recognizer.getRuleNames()[dfa.atnStartState.ruleIndex] + " (alt " + i + ")");
                    }
                } else {
                    System.err.println("  可能的解析路径数: 未知");
                }

                // 显示配置集信息
                if (configs != null && configs.size() > 0) {
                    System.err.println("  配置集详情 (前5个):");
                    int count = 0;
                    for (var config : configs) {
                        if (count >= 5) break;
                        System.err.println("    - 状态: " + config.state + ", Alt: " + config.alt + ", Context: " + config.context);
                        count++;
                    }
                    if (configs.size() > 5) {
                        System.err.println("    ... 还有 " + (configs.size() - 5) + " 个配置");
                    }
                }
                System.err.println();
            }

            @Override
            public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) {
                TokenStream tokens = recognizer.getTokenStream();
                String contextText = tokens.getText(new Interval(startIndex, stopIndex));
                Token startToken = tokens.get(startIndex);
                System.out.println("【JSON性能提示】文件: " + entryName);
                System.out.println("  位置: 第 " + startToken.getLine() + " 行");
                System.out.println("  解析器尝试使用完整上下文进行匹配");
                System.out.println("  上下文文本: " + contextText);
                System.out.println("  Token范围: [" + startIndex + ", " + stopIndex + "]");
                System.out.println();
            }

            @Override
            public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs) {
                TokenStream tokens = recognizer.getTokenStream();
                String contextText = tokens.getText(new Interval(startIndex, stopIndex));
                Token startToken = tokens.get(startIndex);
                System.err.println("【JSON上下文敏感警告】文件: " + entryName);
                System.err.println("  位置: 第 " + startToken.getLine() + " 行");
                System.err.println("  上下文敏感文本: " + contextText);
                System.err.println("  Token范围: [" + startIndex + ", " + stopIndex + "]");
                System.err.println("  预测结果: " + prediction);
                System.err.println("  说明: JSON解析器需要上下文信息才能做出决策");
                System.err.println();
            }
        });
        return parser;
    }

    record ParseContext<L extends Lexer, T extends Parser>(CharStream charStream, TokenStream tokenStream, L lexer, T parser) {

    }
}

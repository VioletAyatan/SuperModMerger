import ankol.mod.merger.antlr.scr.TechlandScriptLexer;
import ankol.mod.merger.antlr.scr.TechlandScriptParser;
import ankol.mod.merger.tools.Tools;
import cn.hutool.core.util.StrUtil;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.atn.ATNConfigSet;
import org.antlr.v4.runtime.dfa.DFA;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.junit.Test;
import tool.TestTool;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.BitSet;
import java.util.Enumeration;
import java.util.HashSet;

public class PakOpenTest {
    private final String[] scrFileSuffix = new String[]{".scr", ".def", ".loot", ".phx", ".ppfx", ".ares", ".mpcloth"};

    /**
     * 遍历Techlandpak包测试
     */
    @Test
    public void test() {
        StringBuilder dltbPath = TestTool.getDltbPath();
        if (dltbPath == null) return;
        String pakFilePath = dltbPath.append(StrUtil.join(File.separator, "", "ph_ft", "source", "data0.pak")).toString();
        System.out.println("pakFilePath = " + pakFilePath);
        long count = 0;
        try (ZipFile zipFile = ZipFile.builder().setFile(pakFilePath).get()) {
            Enumeration<ZipArchiveEntry> entries = zipFile.getEntries();
            while (entries.hasMoreElements()) {
                count++;
                ZipArchiveEntry zipEntry = entries.nextElement();
                String entryName = zipEntry.getName();
                try {
                    if (StrUtil.endWithAny(entryName, scrFileSuffix)) {
                        System.out.println("zipEntry = " + entryName);
                        if (zipEntry.getSize() == 0) {
                            System.err.println("文件为空，跳过处理：" + entryName);
                        } else {
                            TechlandScriptParser parser = getParser(zipFile.getInputStream(zipEntry));
                            parser.addErrorListener(new ANTLRErrorListener() {
                                @Override
                                public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
                                    System.err.println("处理文件：" + entryName + "时，发现语法错误，行号：" + line + "，位置：" + charPositionInLine + "，信息：" + msg);
                                }

                                @Override
                                public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs) {
                                    System.err.println("处理文件：" + entryName + "时，发现二义性，起始位置：" + startIndex + "，结束位置：" + stopIndex);
                                }

                                @Override
                                public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) {
                                    System.out.println("处理文件：" + entryName + "时，尝试完整上下文，起始位置：" + startIndex + "，结束位置：" + stopIndex);
                                }

                                @Override
                                public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs) {
                                    System.err.println("处理文件：" + entryName + "时，发现上下文敏感，起始位置：" + startIndex + "，结束位置：" + stopIndex);
                                }
                            });
                            parser.file();
                        }
                    } else {
                        System.err.println("不支持的类型，跳过处理：" + entryName);
                    }
                } catch (IOException e) {
                    System.err.println("文件：" + entryName + "处理失败，跳过！" + e.getMessage());
                }
            }
            System.out.println("遍历完成，总文件数：" + count + "个");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testDL2() {
        HashSet<String> files = new HashSet<>();
        var path = "D:\\SteamLibrary\\steamapps\\common\\Dying Light 2\\ph\\source\\data0.pak";
        try (ZipFile zipFile = ZipFile.builder().setFile(path).get()) {
            Enumeration<ZipArchiveEntry> entries = zipFile.getEntries();
            while (entries.hasMoreElements()) {
                ZipArchiveEntry zipEntry = entries.nextElement();
                String entryName = zipEntry.getName();
                String fileName = Tools.getEntryFileName(entryName);
                if (files.contains(fileName)) {
                    System.err.println("发现重复的文件：" + fileName + " -> " + entryName);
                } else {
                    files.add(fileName);
//                    System.out.println("entryName = " + entryName);
                }
            }
            System.out.println("完成，总处理文件数：" + files.size() + "个");
        } catch (RuntimeException | IOException e) {
            throw new RuntimeException(e);
        }
    }

    private TechlandScriptParser getParser(InputStream code) throws IOException {
        var input = CharStreams.fromStream(code);
        var lexer = new TechlandScriptLexer(input);
        var tokens = new CommonTokenStream(lexer);
        return new TechlandScriptParser(tokens);
    }
}
